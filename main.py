"""
TikTok Reup Offline - ·ª®ng d·ª•ng offline ƒë·ªÉ t·∫£i xu·ªëng, x·ª≠ l√Ω v√† upload video
"""
import os
import sys
import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import threading
from pathlib import Path

# Th√™m src v√†o path
sys.path.append(os.path.join(os.path.dirname(__file__), 'src'))

from src.utils import ConfigManager, FileManager, Logger
from src.downloader import VideoDownloader
from src.youtube_api import YouTubeAPIService
from src.processor import VideoProcessor
from src.uploader import VideoUploader

class TikTokReupApp:
    """Giao di·ªán ch√≠nh c·ªßa ·ª©ng d·ª•ng"""
    
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("TikTok Reup Offline")
        self.root.geometry("1200x800")
        self.root.resizable(True, True)
        
        # Kh·ªüi t·∫°o c√°c component
        self.config = ConfigManager()
        self.downloader = VideoDownloader(self.config)
        self.youtube_api = YouTubeAPIService(self.config.get('download.youtube_api_key'))
        self.processor = VideoProcessor(self.config)
        self.uploader = VideoUploader(self.config)
        
        # Thi·∫øt l·∫≠p logging
        Logger.setup_logging()
        
        # T·∫°o giao di·ªán
        self.create_widgets()
        
        # Bi·∫øn tr·∫°ng th√°i
        self.is_processing = False
        self.downloaded_files = []
        self.processed_files = []
    
    def create_widgets(self):
        """T·∫°o c√°c widget giao di·ªán"""
        # T·∫°o notebook cho c√°c tab
        self.notebook = ttk.Notebook(self.root)
        self.notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Tab Download
        self.create_download_tab()
        
        # Tab Download List Channel TikTok
        self.create_download_channel_tiktok_tab()
        
        # Tab Download List Channel YouTube
        self.create_download_channel_youtube_tab()
        
        # Tab Process
        self.create_process_tab()
        
        # Tab Upload
        self.create_upload_tab()
        
        # Tab Settings
        self.create_settings_tab()
        
        # Status bar
        self.create_status_bar()
    
    def create_download_tab(self):
        """T·∫°o tab Download"""
        download_frame = ttk.Frame(self.notebook)
        self.notebook.add(download_frame, text="üì• Download")
        
        # URL input
        url_frame = ttk.LabelFrame(download_frame, text="URL Video", padding=10)
        url_frame.pack(fill=tk.X, padx=10, pady=5)
        
        self.url_var = tk.StringVar()
        url_entry = ttk.Entry(url_frame, textvariable=self.url_var, width=80)
        url_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        
        self.download_btn = ttk.Button(url_frame, text="Download", 
                                     command=self.download_video)
        self.download_btn.pack(side=tk.RIGHT)
        
        # Video info
        info_frame = ttk.LabelFrame(download_frame, text="Th√¥ng tin Video", padding=10)
        info_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        self.info_text = tk.Text(info_frame, height=10, wrap=tk.WORD)
        info_scrollbar = ttk.Scrollbar(info_frame, orient=tk.VERTICAL, command=self.info_text.yview)
        self.info_text.configure(yscrollcommand=info_scrollbar.set)
        
        self.info_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        info_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Downloaded files list
        files_frame = ttk.LabelFrame(download_frame, text="Files ƒë√£ t·∫£i", padding=10)
        files_frame.pack(fill=tk.X, padx=10, pady=5)
        
        self.files_listbox = tk.Listbox(files_frame, height=6)
        files_scrollbar = ttk.Scrollbar(files_frame, orient=tk.VERTICAL, command=self.files_listbox.yview)
        self.files_listbox.configure(yscrollcommand=files_scrollbar.set)
        
        self.files_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        files_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Buttons
        btn_frame = ttk.Frame(files_frame)
        btn_frame.pack(fill=tk.X, pady=(10, 0))
        
        ttk.Button(btn_frame, text="X√≥a file", command=self.delete_selected_file).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(btn_frame, text="M·ªü th∆∞ m·ª•c", command=self.open_download_folder).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(btn_frame, text="Refresh", command=self.refresh_files_list).pack(side=tk.LEFT)

        # Progress bar
        progress_frame = ttk.Frame(download_frame)
        progress_frame.pack(fill=tk.X, padx=10, pady=(5, 0))
        self.download_progress = ttk.Progressbar(progress_frame, orient=tk.HORIZONTAL, mode='determinate', maximum=100)
        self.download_progress.pack(side=tk.LEFT, fill=tk.X, expand=True)
        self.download_progress_label = ttk.Label(progress_frame, text="0%")
        self.download_progress_label.pack(side=tk.LEFT, padx=(10,0))

    def create_download_channel_tiktok_tab(self):
        """T·∫°o tab Download List Channel TikTok"""
        channel_frame = ttk.Frame(self.notebook)
        self.notebook.add(channel_frame, text="üìö Download List Channel TikTok")
        
        # URL k√™nh
        url_frame = ttk.LabelFrame(channel_frame, text="URL K√™nh/Playlist/Profile", padding=10)
        url_frame.pack(fill=tk.X, padx=10, pady=5)
        self.channel_url_var = tk.StringVar()
        ttk.Entry(url_frame, textvariable=self.channel_url_var, width=80).pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0,10))
        ttk.Button(url_frame, text="L·∫•y danh s√°ch", command=self.fetch_channel_list).pack(side=tk.RIGHT)
        
        # Danh s√°ch video (Treeview 4 c·ªôt)
        list_frame = ttk.LabelFrame(channel_frame, text="Danh s√°ch video", padding=10)
        list_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        columns = ("stt", "title", "progress", "selected")
        self.channel_tree = ttk.Treeview(list_frame, columns=columns, show='headings', selectmode='extended', height=14)
        self.channel_tree.heading('stt', text='STT')
        self.channel_tree.heading('title', text='Ti√™u ƒë·ªÅ')
        self.channel_tree.heading('progress', text='Ti·∫øn tr√¨nh')
        self.channel_tree.heading('selected', text='T·∫£i?')
        self.channel_tree.column('stt', width=50, anchor=tk.CENTER, stretch=False)
        self.channel_tree.column('title', width=700, anchor=tk.W)
        self.channel_tree.column('progress', width=100, anchor=tk.CENTER, stretch=False)
        self.channel_tree.column('selected', width=60, anchor=tk.CENTER, stretch=False)
        list_scrollbar = ttk.Scrollbar(list_frame, orient=tk.VERTICAL, command=self.channel_tree.yview)
        self.channel_tree.configure(yscrollcommand=list_scrollbar.set)
        self.channel_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        list_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        # Toggle checkbox khi click c·ªôt 'selected'
        self.channel_tree.bind('<Button-1>', self.on_channel_tree_click)
        # Menu chu·ªôt ph·∫£i
        self.channel_context_menu = tk.Menu(self.root, tearoff=0)
        self.channel_context_menu.add_command(label="X√≥a video ƒë√£ ch·ªçn", command=self.delete_selected_channel_videos)
        self.channel_context_menu.add_command(label="T·∫£i video ƒë√£ ch·ªçn", command=lambda: self.download_channel_videos(selected_only=True))
        self.channel_context_menu.add_separator()
        self.channel_context_menu.add_command(label="Ch·ªçn t·∫•t c·∫£", command=self.select_all_channel_videos)
        self.channel_context_menu.add_command(label="B·ªè ch·ªçn t·∫•t c·∫£", command=self.deselect_all_channel_videos)
        self.channel_tree.bind('<Button-3>', self.show_channel_context_menu)
        
        # Buttons
        actions = ttk.Frame(channel_frame)
        actions.pack(fill=tk.X, padx=10, pady=(0,5))
        ttk.Button(actions, text="T·∫£i ƒë√£ ch·ªçn", command=lambda: self.download_channel_videos(selected_only=True)).pack(side=tk.LEFT)
        ttk.Button(actions, text="T·∫£i t·∫•t c·∫£", command=lambda: self.download_channel_videos(selected_only=False)).pack(side=tk.LEFT, padx=(10,0))
        ttk.Button(actions, text="T·∫£i l·∫°i video l·ªói", command=self.retry_failed_videos).pack(side=tk.LEFT, padx=(10,0))
        ttk.Button(actions, text="X√≥a video ƒë√£ ch·ªçn", command=self.delete_selected_channel_videos).pack(side=tk.LEFT, padx=(10,0))
        ttk.Button(actions, text="X√≥a t·∫•t c·∫£", command=self.delete_all_channel_videos).pack(side=tk.LEFT, padx=(10,0))
        
        # Progress t·ªïng
        progress_frame = ttk.Frame(channel_frame)
        progress_frame.pack(fill=tk.X, padx=10, pady=(5, 0))
        self.channel_progress = ttk.Progressbar(progress_frame, orient=tk.HORIZONTAL, mode='determinate', maximum=100)
        self.channel_progress.pack(side=tk.LEFT, fill=tk.X, expand=True)
        self.channel_progress_label = ttk.Label(progress_frame, text="0%")
        self.channel_progress_label.pack(side=tk.LEFT, padx=(10,0))
        
        # L∆∞u danh s√°ch videos (m·ªói item: title,url,id,duration,selected,progress)
        self.channel_videos = []
    
    def create_download_channel_youtube_tab(self):
        """T·∫°o tab Download List Channel YouTube"""
        youtube_frame = ttk.Frame(self.notebook)
        self.notebook.add(youtube_frame, text="üì∫ Download List Channel YouTube")
        
        # API Status
        api_frame = ttk.LabelFrame(youtube_frame, text="Tr·∫°ng th√°i API", padding=10)
        api_frame.pack(fill=tk.X, padx=10, pady=5)
        
        self.api_status_var = tk.StringVar()
        self.api_status_label = ttk.Label(api_frame, textvariable=self.api_status_var)
        self.api_status_label.pack(side=tk.LEFT)
        
        ttk.Button(api_frame, text="Test API", command=self.test_youtube_api).pack(side=tk.RIGHT)
        
        # URL k√™nh
        url_frame = ttk.LabelFrame(youtube_frame, text="URL K√™nh YouTube", padding=10)
        url_frame.pack(fill=tk.X, padx=10, pady=5)
        
        # URL input
        url_input_frame = ttk.Frame(url_frame)
        url_input_frame.pack(fill=tk.X, pady=(0, 5))
        self.youtube_url_var = tk.StringVar()
        ttk.Entry(url_input_frame, textvariable=self.youtube_url_var, width=60).pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0,10))
        
        # S·ªë l∆∞·ª£ng video
        count_frame = ttk.Frame(url_frame)
        count_frame.pack(fill=tk.X)
        ttk.Label(count_frame, text="S·ªë video:").pack(side=tk.LEFT)
        self.youtube_count_var = tk.StringVar(value="200")
        count_combo = ttk.Combobox(count_frame, textvariable=self.youtube_count_var, 
                                  values=["50", "100", "200", "500"], width=10, state="readonly")
        count_combo.pack(side=tk.LEFT, padx=(5, 10))
        
        ttk.Button(url_input_frame, text="L·∫•y danh s√°ch", command=self.fetch_youtube_channel_list).pack(side=tk.RIGHT)
        
        # Th√¥ng tin channel
        info_frame = ttk.LabelFrame(youtube_frame, text="Th√¥ng tin Channel", padding=10)
        info_frame.pack(fill=tk.X, padx=10, pady=5)
        
        self.youtube_info_text = tk.Text(info_frame, height=4, wrap=tk.WORD)
        info_scrollbar = ttk.Scrollbar(info_frame, orient=tk.VERTICAL, command=self.youtube_info_text.yview)
        self.youtube_info_text.configure(yscrollcommand=info_scrollbar.set)
        
        self.youtube_info_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        info_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Danh s√°ch video (Treeview 5 c·ªôt)
        list_frame = ttk.LabelFrame(youtube_frame, text="Danh s√°ch video", padding=10)
        list_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        columns = ("stt", "title", "duration", "views", "progress", "selected")
        self.youtube_tree = ttk.Treeview(list_frame, columns=columns, show='headings', selectmode='extended', height=12)
        self.youtube_tree.heading('stt', text='STT')
        self.youtube_tree.heading('title', text='Ti√™u ƒë·ªÅ')
        self.youtube_tree.heading('duration', text='Th·ªùi l∆∞·ª£ng')
        self.youtube_tree.heading('views', text='L∆∞·ª£t xem')
        self.youtube_tree.heading('progress', text='Ti·∫øn tr√¨nh')
        self.youtube_tree.heading('selected', text='T·∫£i?')
        self.youtube_tree.column('stt', width=50, anchor=tk.CENTER, stretch=False)
        self.youtube_tree.column('title', width=500, anchor=tk.W)
        self.youtube_tree.column('duration', width=80, anchor=tk.CENTER, stretch=False)
        self.youtube_tree.column('views', width=100, anchor=tk.CENTER, stretch=False)
        self.youtube_tree.column('progress', width=80, anchor=tk.CENTER, stretch=False)
        self.youtube_tree.column('selected', width=60, anchor=tk.CENTER, stretch=False)
        list_scrollbar = ttk.Scrollbar(list_frame, orient=tk.VERTICAL, command=self.youtube_tree.yview)
        self.youtube_tree.configure(yscrollcommand=list_scrollbar.set)
        self.youtube_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        list_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Toggle checkbox khi click c·ªôt 'selected'
        self.youtube_tree.bind('<Button-1>', self.on_youtube_tree_click)
        
        # Menu chu·ªôt ph·∫£i
        self.youtube_context_menu = tk.Menu(self.root, tearoff=0)
        self.youtube_context_menu.add_command(label="X√≥a video ƒë√£ ch·ªçn", command=self.delete_selected_youtube_videos)
        self.youtube_context_menu.add_command(label="T·∫£i video ƒë√£ ch·ªçn", command=lambda: self.download_youtube_videos(selected_only=True))
        self.youtube_context_menu.add_separator()
        self.youtube_context_menu.add_command(label="Ch·ªçn t·∫•t c·∫£", command=self.select_all_youtube_videos)
        self.youtube_context_menu.add_command(label="B·ªè ch·ªçn t·∫•t c·∫£", command=self.deselect_all_youtube_videos)
        self.youtube_tree.bind('<Button-3>', self.show_youtube_context_menu)
        
        # Buttons
        actions = ttk.Frame(youtube_frame)
        actions.pack(fill=tk.X, padx=10, pady=(0,5))
        ttk.Button(actions, text="T·∫£i ƒë√£ ch·ªçn", command=lambda: self.download_youtube_videos(selected_only=True)).pack(side=tk.LEFT)
        ttk.Button(actions, text="T·∫£i t·∫•t c·∫£", command=lambda: self.download_youtube_videos(selected_only=False)).pack(side=tk.LEFT, padx=(10,0))
        ttk.Button(actions, text="T·∫£i l·∫°i video l·ªói", command=self.retry_failed_youtube_videos).pack(side=tk.LEFT, padx=(10,0))
        ttk.Button(actions, text="X√≥a video ƒë√£ ch·ªçn", command=self.delete_selected_youtube_videos).pack(side=tk.LEFT, padx=(10,0))
        ttk.Button(actions, text="X√≥a t·∫•t c·∫£", command=self.delete_all_youtube_videos).pack(side=tk.LEFT, padx=(10,0))
        
        # Progress t·ªïng
        progress_frame = ttk.Frame(youtube_frame)
        progress_frame.pack(fill=tk.X, padx=10, pady=(5, 0))
        self.youtube_progress = ttk.Progressbar(progress_frame, orient=tk.HORIZONTAL, mode='determinate', maximum=100)
        self.youtube_progress.pack(side=tk.LEFT, fill=tk.X, expand=True)
        self.youtube_progress_label = ttk.Label(progress_frame, text="0%")
        self.youtube_progress_label.pack(side=tk.LEFT, padx=(10,0))
        
        # L∆∞u danh s√°ch videos YouTube
        self.youtube_videos = []
        
        # C·∫≠p nh·∫≠t tr·∫°ng th√°i API
        self.update_youtube_api_status()
    
    def create_process_tab(self):
        """T·∫°o tab Process"""
        process_frame = ttk.Frame(self.notebook)
        self.notebook.add(process_frame, text="‚úÇÔ∏è Process")
        
        # File selection
        file_frame = ttk.LabelFrame(process_frame, text="Ch·ªçn file video", padding=10)
        file_frame.pack(fill=tk.X, padx=10, pady=5)
        
        self.process_file_var = tk.StringVar()
        file_entry = ttk.Entry(file_frame, textvariable=self.process_file_var, width=70)
        file_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        
        ttk.Button(file_frame, text="Browse", command=self.browse_video_file).pack(side=tk.RIGHT)
        
        # Processing options
        options_frame = ttk.LabelFrame(process_frame, text="T√πy ch·ªçn x·ª≠ l√Ω", padding=10)
        options_frame.pack(fill=tk.X, padx=10, pady=5)
        
        # Cut options
        cut_frame = ttk.Frame(options_frame)
        cut_frame.pack(fill=tk.X, pady=5)
        
        ttk.Label(cut_frame, text="C·∫Øt video:").pack(side=tk.LEFT)
        self.cut_var = tk.StringVar(value="none")
        cut_combo = ttk.Combobox(cut_frame, textvariable=self.cut_var, 
                               values=["none", "1min", "3min", "5min", "10min", "30min"],
                               state="readonly", width=10)
        cut_combo.pack(side=tk.LEFT, padx=(10, 0))
        
        # Watermark options
        watermark_frame = ttk.Frame(options_frame)
        watermark_frame.pack(fill=tk.X, pady=5)
        
        self.watermark_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(watermark_frame, text="Th√™m watermark", 
                       variable=self.watermark_var).pack(side=tk.LEFT)
        
        self.watermark_text_var = tk.StringVar(value="TikTok Reup Offline")
        ttk.Entry(watermark_frame, textvariable=self.watermark_text_var, width=30).pack(side=tk.LEFT, padx=(10, 0))
        
        # Speed options
        speed_frame = ttk.Frame(options_frame)
        speed_frame.pack(fill=tk.X, pady=5)
        
        ttk.Label(speed_frame, text="T·ªëc ƒë·ªô:").pack(side=tk.LEFT)
        self.speed_var = tk.DoubleVar(value=1.0)
        speed_scale = ttk.Scale(speed_frame, from_=0.5, to=2.0, variable=self.speed_var, 
                               orient=tk.HORIZONTAL, length=200)
        speed_scale.pack(side=tk.LEFT, padx=(10, 0))
        
        self.speed_label = ttk.Label(speed_frame, text="1.0x")
        self.speed_label.pack(side=tk.LEFT, padx=(10, 0))
        
        # Other options
        other_frame = ttk.Frame(options_frame)
        other_frame.pack(fill=tk.X, pady=5)
        
        self.flip_var = tk.StringVar(value="none")
        ttk.Label(other_frame, text="L·∫≠t:").pack(side=tk.LEFT)
        ttk.Radiobutton(other_frame, text="Kh√¥ng", variable=self.flip_var, value="none").pack(side=tk.LEFT, padx=(10, 0))
        ttk.Radiobutton(other_frame, text="Ngang", variable=self.flip_var, value="horizontal").pack(side=tk.LEFT, padx=(5, 0))
        ttk.Radiobutton(other_frame, text="D·ªçc", variable=self.flip_var, value="vertical").pack(side=tk.LEFT, padx=(5, 0))
        
        self.convert_916_var = tk.BooleanVar(value=False)
        ttk.Checkbutton(other_frame, text="Chuy·ªÉn 9:16", 
                       variable=self.convert_916_var).pack(side=tk.LEFT, padx=(20, 0))
        
        self.change_md5_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(other_frame, text="Thay ƒë·ªïi MD5", 
                       variable=self.change_md5_var).pack(side=tk.LEFT, padx=(10, 0))
        
        # Process button
        process_btn_frame = ttk.Frame(process_frame)
        process_btn_frame.pack(fill=tk.X, padx=10, pady=10)
        
        self.process_btn = ttk.Button(process_btn_frame, text="X·ª≠ l√Ω Video", 
                                    command=self.process_video, style="Accent.TButton")
        self.process_btn.pack(side=tk.LEFT)
        
        # Process log
        log_frame = ttk.LabelFrame(process_frame, text="Log x·ª≠ l√Ω", padding=10)
        log_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        self.process_log = tk.Text(log_frame, height=8, wrap=tk.WORD)
        log_scrollbar = ttk.Scrollbar(log_frame, orient=tk.VERTICAL, command=self.process_log.yview)
        self.process_log.configure(yscrollcommand=log_scrollbar.set)
        
        self.process_log.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        log_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Bind events
        speed_scale.configure(command=self.update_speed_label)
    
    def create_upload_tab(self):
        """T·∫°o tab Upload"""
        upload_frame = ttk.Frame(self.notebook)
        self.notebook.add(upload_frame, text="üì§ Upload")
        
        # File selection
        file_frame = ttk.LabelFrame(upload_frame, text="Ch·ªçn file video", padding=10)
        file_frame.pack(fill=tk.X, padx=10, pady=5)
        
        self.upload_file_var = tk.StringVar()
        file_entry = ttk.Entry(file_frame, textvariable=self.upload_file_var, width=70)
        file_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        
        ttk.Button(file_frame, text="Browse", command=self.browse_upload_file).pack(side=tk.RIGHT)
        
        # Platform selection
        platform_frame = ttk.LabelFrame(upload_frame, text="N·ªÅn t·∫£ng", padding=10)
        platform_frame.pack(fill=tk.X, padx=10, pady=5)
        
        self.platform_var = tk.StringVar(value="tiktok")
        ttk.Radiobutton(platform_frame, text="TikTok", variable=self.platform_var, value="tiktok").pack(side=tk.LEFT)
        ttk.Radiobutton(platform_frame, text="YouTube", variable=self.platform_var, value="youtube").pack(side=tk.LEFT, padx=(20, 0))
        ttk.Radiobutton(platform_frame, text="Facebook", variable=self.platform_var, value="facebook").pack(side=tk.LEFT, padx=(20, 0))
        
        # Upload content
        content_frame = ttk.LabelFrame(upload_frame, text="N·ªôi dung", padding=10)
        content_frame.pack(fill=tk.X, padx=10, pady=5)
        
        ttk.Label(content_frame, text="Ti√™u ƒë·ªÅ:").pack(anchor=tk.W)
        self.title_var = tk.StringVar()
        ttk.Entry(content_frame, textvariable=self.title_var, width=80).pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(content_frame, text="M√¥ t·∫£:").pack(anchor=tk.W)
        self.description_var = tk.StringVar()
        ttk.Entry(content_frame, textvariable=self.description_var, width=80).pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(content_frame, text="Hashtags:").pack(anchor=tk.W)
        self.hashtags_var = tk.StringVar()
        ttk.Entry(content_frame, textvariable=self.hashtags_var, width=80).pack(fill=tk.X)
        
        # Upload button
        upload_btn_frame = ttk.Frame(upload_frame)
        upload_btn_frame.pack(fill=tk.X, padx=10, pady=10)
        
        self.upload_btn = ttk.Button(upload_btn_frame, text="Upload Video", 
                                   command=self.upload_video, style="Accent.TButton")
        self.upload_btn.pack(side=tk.LEFT)
        
        # Upload log
        log_frame = ttk.LabelFrame(upload_frame, text="Log upload", padding=10)
        log_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        self.upload_log = tk.Text(log_frame, height=8, wrap=tk.WORD)
        log_scrollbar = ttk.Scrollbar(log_frame, orient=tk.VERTICAL, command=self.upload_log.yview)
        self.upload_log.configure(yscrollcommand=log_scrollbar.set)
        
        self.upload_log.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        log_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
    
    def create_settings_tab(self):
        """T·∫°o tab Settings"""
        settings_frame = ttk.Frame(self.notebook)
        self.notebook.add(settings_frame, text="‚öôÔ∏è Settings")
        
        # Download settings
        download_frame = ttk.LabelFrame(settings_frame, text="C√†i ƒë·∫∑t Download", padding=10)
        download_frame.pack(fill=tk.X, padx=10, pady=5)
        
        ttk.Label(download_frame, text="ƒê·ªô ph√¢n gi·∫£i:").pack(anchor=tk.W)
        self.resolution_var = tk.StringVar(value=self.config.get('download.resolution', '1080p'))
        resolution_combo = ttk.Combobox(download_frame, textvariable=self.resolution_var,
                                      values=['360p', '480p', '720p', '1080p'], state="readonly")
        resolution_combo.pack(anchor=tk.W, fill=tk.X, pady=(0, 10))
        
        ttk.Label(download_frame, text="Th∆∞ m·ª•c l∆∞u:").pack(anchor=tk.W)
        folder_frame = ttk.Frame(download_frame)
        folder_frame.pack(fill=tk.X, pady=(0, 10))
        
        self.download_folder_var = tk.StringVar(value=self.config.get('download.output_path', 'data/videos'))
        ttk.Entry(folder_frame, textvariable=self.download_folder_var).pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        ttk.Button(folder_frame, text="Browse", command=self.browse_download_folder).pack(side=tk.RIGHT)
        
        # Process settings
        process_frame = ttk.LabelFrame(settings_frame, text="C√†i ƒë·∫∑t x·ª≠ l√Ω", padding=10)
        process_frame.pack(fill=tk.X, padx=10, pady=5)
        
        ttk.Label(process_frame, text="Th∆∞ m·ª•c x·ª≠ l√Ω:").pack(anchor=tk.W)
        process_folder_frame = ttk.Frame(process_frame)
        process_folder_frame.pack(fill=tk.X, pady=(0, 10))
        
        self.process_folder_var = tk.StringVar(value=self.config.get('processing.output_path', 'data/processed'))
        ttk.Entry(process_folder_frame, textvariable=self.process_folder_var).pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        ttk.Button(process_folder_frame, text="Browse", command=self.browse_process_folder).pack(side=tk.RIGHT)
        
        # YouTube API settings
        youtube_frame = ttk.LabelFrame(settings_frame, text="C√†i ƒë·∫∑t YouTube API", padding=10)
        youtube_frame.pack(fill=tk.X, padx=10, pady=5)
        
        ttk.Label(youtube_frame, text="YouTube API Key:").pack(anchor=tk.W)
        self.youtube_api_key_var = tk.StringVar(value=self.config.get('download.youtube_api_key', ''))
        youtube_key_entry = ttk.Entry(youtube_frame, textvariable=self.youtube_api_key_var, show="*", width=60)
        youtube_key_entry.pack(fill=tk.X, pady=(0, 5))
        
        ttk.Label(youtube_frame, text="H∆∞·ªõng d·∫´n:", font=("Arial", 8)).pack(anchor=tk.W)
        ttk.Label(youtube_frame, text="1. Truy c·∫≠p https://console.developers.google.com/", font=("Arial", 8)).pack(anchor=tk.W)
        ttk.Label(youtube_frame, text="2. T·∫°o project m·ªõi ho·∫∑c ch·ªçn project hi·ªán c√≥", font=("Arial", 8)).pack(anchor=tk.W)
        ttk.Label(youtube_frame, text="3. B·∫≠t YouTube Data API v3", font=("Arial", 8)).pack(anchor=tk.W)
        ttk.Label(youtube_frame, text="4. T·∫°o API key v√† d√°n v√†o √¥ tr√™n", font=("Arial", 8)).pack(anchor=tk.W)
        
        # FFmpeg settings
        ffmpeg_frame = ttk.LabelFrame(settings_frame, text="C√†i ƒë·∫∑t FFmpeg", padding=10)
        ffmpeg_frame.pack(fill=tk.X, padx=10, pady=5)
        
        ttk.Label(ffmpeg_frame, text="ƒê∆∞·ªùng d·∫´n FFmpeg:").pack(anchor=tk.W)
        ffmpeg_path_frame = ttk.Frame(ffmpeg_frame)
        ffmpeg_path_frame.pack(fill=tk.X, pady=(0, 10))
        
        self.ffmpeg_path_var = tk.StringVar(value=self.config.get('ffmpeg.path', 'tools/ffmpeg.exe'))
        ttk.Entry(ffmpeg_path_frame, textvariable=self.ffmpeg_path_var).pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        ttk.Button(ffmpeg_path_frame, text="Browse", command=self.browse_ffmpeg_path).pack(side=tk.RIGHT)
        
        # Save button
        save_btn_frame = ttk.Frame(settings_frame)
        save_btn_frame.pack(fill=tk.X, padx=10, pady=20)
        
        ttk.Button(save_btn_frame, text="L∆∞u c√†i ƒë·∫∑t", command=self.save_settings).pack(side=tk.LEFT)
        ttk.Button(save_btn_frame, text="Reset", command=self.reset_settings).pack(side=tk.LEFT, padx=(10, 0))
    
    def create_status_bar(self):
        """T·∫°o status bar"""
        self.status_var = tk.StringVar(value="S·∫µn s√†ng")
        status_bar = ttk.Label(self.root, textvariable=self.status_var, relief=tk.SUNKEN, anchor=tk.W)
        status_bar.pack(side=tk.BOTTOM, fill=tk.X)
    
    def update_status(self, message):
        """C·∫≠p nh·∫≠t status bar"""
        self.status_var.set(message)
        self.root.update_idletasks()
    
    def update_speed_label(self, value):
        """C·∫≠p nh·∫≠t label t·ªëc ƒë·ªô"""
        self.speed_label.config(text=f"{float(value):.1f}x")
    
    def download_video(self):
        """T·∫£i video"""
        url = self.url_var.get().strip()
        if not url:
            messagebox.showerror("L·ªói", "Vui l√≤ng nh·∫≠p URL video")
            return
        
        if not self.downloader.is_supported_url(url):
            messagebox.showerror("L·ªói", "URL kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£")
            return
        
        def download_thread():
            try:
                self.update_status("ƒêang l·∫•y th√¥ng tin video...")
                self.download_btn.config(state="disabled")
                # ƒê·ªìng b·ªô c√†i ƒë·∫∑t m·ªõi nh·∫•t v√†o downloader
                self.downloader.reload_settings()
                # Reset ti·∫øn tr√¨nh ƒë·∫ßu l∆∞·ª£t t·∫£i
                self.root.after(0, self.update_download_progress, 0.0)
                
                # L·∫•y th√¥ng tin video
                info = self.downloader.get_video_info(url)
                if info:
                    self.root.after(0, self.display_video_info, info)
                
                self.update_status("ƒêang t·∫£i video...")

                def hook(d):
                    try:
                        status = d.get('status')
                        percent = None
                        if status == 'downloading':
                            downloaded = d.get('downloaded_bytes') or 0
                            total = d.get('total_bytes') or d.get('total_bytes_estimate') or 0
                            if total:
                                percent = downloaded * 100.0 / float(total)
                            else:
                                # Fallback theo fragment (HLS/DASH)
                                frag_idx = d.get('fragment_index') or 0
                                frag_cnt = d.get('fragment_count') or 0
                                if frag_cnt:
                                    percent = frag_idx * 100.0 / float(frag_cnt)
                        elif status == 'finished':
                            percent = 100.0
                        if percent is not None:
                            self.root.after(0, self.update_download_progress, percent)
                    except Exception:
                        pass

                file_path = self.downloader.download_video(url, progress_hook=hook)
                
                if file_path:
                    self.root.after(0, self.download_success, file_path)
                else:
                    self.root.after(0, self.download_error)
                    
            except Exception as e:
                self.root.after(0, self.download_error, str(e))
            finally:
                self.root.after(0, self.download_finish)
        
        threading.Thread(target=download_thread, daemon=True).start()
    
    def display_video_info(self, info):
        """Hi·ªÉn th·ªã th√¥ng tin video"""
        self.info_text.delete(1.0, tk.END)
        self.info_text.insert(tk.END, f"Ti√™u ƒë·ªÅ: {info.get('title', 'N/A')}\n")
        self.info_text.insert(tk.END, f"Th·ªùi l∆∞·ª£ng: {info.get('duration', 0)} gi√¢y\n")
        self.info_text.insert(tk.END, f"Ng∆∞·ªùi ƒëƒÉng: {info.get('uploader', 'N/A')}\n")
        self.info_text.insert(tk.END, f"L∆∞·ª£t xem: {info.get('view_count', 0):,}\n")
        self.info_text.insert(tk.END, f"L∆∞·ª£t th√≠ch: {info.get('like_count', 0):,}\n")
        self.info_text.insert(tk.END, f"N·ªÅn t·∫£ng: {info.get('platform', 'N/A')}\n")
        self.info_text.insert(tk.END, f"URL: {info.get('url', 'N/A')}\n")
    
    def download_success(self, file_path):
        """X·ª≠ l√Ω khi t·∫£i th√†nh c√¥ng"""
        self.downloaded_files.append(file_path)
        self.files_listbox.insert(tk.END, os.path.basename(file_path))
        # C·∫≠p nh·∫≠t ti·∫øn tr√¨nh 100%
        self.update_download_progress(100.0)
        messagebox.showinfo("Th√†nh c√¥ng", f"T·∫£i video th√†nh c√¥ng:\n{file_path}")
    
    def download_error(self, error_msg=None):
        """X·ª≠ l√Ω khi t·∫£i l·ªói"""
        msg = error_msg or "L·ªói t·∫£i video"
        messagebox.showerror("L·ªói", msg)
    
    def download_finish(self):
        """K·∫øt th√∫c t·∫£i"""
        self.download_btn.config(state="normal")
        self.update_status("S·∫µn s√†ng")
        # Gi·ªØ nguy√™n ti·∫øn tr√¨nh ƒë·ªÉ ng∆∞·ªùi d√πng k·ªãp quan s√°t
    
    def update_download_progress(self, percent: float):
        """C·∫≠p nh·∫≠t thanh ti·∫øn tr√¨nh t·∫£i"""
        try:
            value = max(0, min(100, float(percent)))
        except Exception:
            value = 0.0
        self.download_progress['value'] = value
        self.download_progress_label.config(text=f"{value:.0f}%")
        self.root.update_idletasks()

    def fetch_channel_list(self):
        """L·∫•y danh s√°ch video public do ch·ªß k√™nh ƒëƒÉng"""
        url = self.channel_url_var.get().strip()
        if not url:
            messagebox.showerror("L·ªói", "Vui l√≤ng nh·∫≠p URL k√™nh ho·∫∑c playlist")
            return
        
        def fetch_thread():
            try:
                self.update_status("ƒêang l·∫•y danh s√°ch video...")
                videos = self.downloader.list_channel_videos(url, max_videos=50)
                # Kh·ªüi t·∫°o th√™m thu·ªôc t√≠nh 'selected' v√† 'progress' cho m·ªói video
                self.channel_videos = [{**v, 'selected': True, 'progress': 0.0} for v in videos]
                def update_ui():
                    self.refresh_channel_list_display()
                    self.update_status(f"ƒê√£ l·∫•y {len(videos)} video")
                    self.update_channel_progress(0)
                self.root.after(0, update_ui)
            except Exception as e:
                self.root.after(0, messagebox.showerror, "L·ªói", f"Kh√¥ng l·∫•y ƒë∆∞·ª£c danh s√°ch: {e}")
                self.root.after(0, self.update_status, "S·∫µn s√†ng")
        threading.Thread(target=fetch_thread, daemon=True).start()

    def download_channel_videos(self, selected_only: bool):
        """T·∫£i c√°c video trong danh s√°ch (ƒë√£ ch·ªçn ho·∫∑c t·∫•t c·∫£)"""
        if not self.channel_videos:
            messagebox.showwarning("C·∫£nh b√°o", "Ch∆∞a c√≥ danh s√°ch video ƒë·ªÉ t·∫£i")
            return
        
        if selected_only:
            indices = [i for i, v in enumerate(self.channel_videos) if v.get('selected')]
        else:
            indices = list(range(len(self.channel_videos)))
        if not indices:
            messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng ch·ªçn video ƒë·ªÉ t·∫£i")
            return
        
        def batch_thread():
            try:
                import time
                total = len(indices)
                successful_downloads = 0
                self.update_status(f"ƒêang t·∫£i danh s√°ch ({total} video)...")
                
                for idx_pos, idx in enumerate(indices, start=1):
                    video = self.channel_videos[idx]
                    url = video.get('url')
                    title = video.get('title') or video.get('id')
                    
                    # C·∫≠p nh·∫≠t ti·∫øn tr√¨nh t·ªïng
                    self.root.after(0, self.update_channel_progress, (idx_pos-1) * 100.0 / total)
                    self.root.after(0, self.update_row_progress, idx, 0.0)
                    
                    # Th·ª≠ t·∫£i v·ªõi retry
                    success = False
                    for retry in range(3):  # Th·ª≠ t·ªëi ƒëa 3 l·∫ßn
                        try:
                            def hook(d):
                                try:
                                    status = d.get('status')
                                    file_percent = None
                                    if status == 'downloading':
                                        downloaded = d.get('downloaded_bytes') or 0
                                        t = d.get('total_bytes') or d.get('total_bytes_estimate') or 0
                                        if t:
                                            file_percent = downloaded * 100.0 / float(t)
                                        else:
                                            fi = d.get('fragment_index') or 0
                                            fc = d.get('fragment_count') or 0
                                            if fc:
                                                file_percent = fi * 100.0 / float(fc)
                                    elif status == 'finished':
                                        file_percent = 100.0
                                    if file_percent is not None:
                                        overall = (idx_pos-1) * 100.0 / total + (file_percent / total)
                                        self.root.after(0, self.update_channel_progress, overall)
                                        self.root.after(0, self.update_row_progress, idx, file_percent)
                                except Exception:
                                    pass
                            
                            result = self.downloader.download_video(url, custom_filename=None, progress_hook=hook)
                            if result:
                                success = True
                                successful_downloads += 1
                                self.root.after(0, self.update_row_progress, idx, 100.0)
                                break
                            else:
                                if retry < 2:  # Ch∆∞a h·∫øt l·∫ßn th·ª≠
                                    self.root.after(0, self.update_row_progress, idx, 0.0)
                                    time.sleep(2)  # Delay 2 gi√¢y tr∆∞·ªõc khi th·ª≠ l·∫°i
                                    
                        except Exception as e:
                            if retry < 2:
                                time.sleep(2)
                            else:
                                self.root.after(0, self.update_row_progress, idx, 0.0)
                    
                    if not success:
                        self.root.after(0, self.update_row_progress, idx, 0.0)
                    
                    # Delay gi·ªØa c√°c video ƒë·ªÉ tr√°nh rate limiting
                    if idx_pos < total:
                        time.sleep(1)
                
                self.root.after(0, self.update_channel_progress, 100.0)
                self.root.after(0, self.update_status, f"Ho√†n t·∫•t: {successful_downloads}/{total} video th√†nh c√¥ng")
                
                if successful_downloads < total:
                    self.root.after(0, messagebox.showwarning, "C·∫£nh b√°o", 
                                  f"Ch·ªâ t·∫£i ƒë∆∞·ª£c {successful_downloads}/{total} video. C√≥ th·ªÉ do:\n"
                                  "- Firewall/antivirus ch·∫∑n k·∫øt n·ªëi\n"
                                  "- TikTok rate limiting\n"
                                  "- M·∫°ng kh√¥ng ·ªïn ƒë·ªãnh")
                
            except Exception as e:
                self.root.after(0, messagebox.showerror, "L·ªói", f"L·ªói t·∫£i danh s√°ch: {e}")
                self.root.after(0, self.update_status, "S·∫µn s√†ng")
        threading.Thread(target=batch_thread, daemon=True).start()

    def retry_failed_videos(self):
        """T·∫£i l·∫°i nh·ªØng video b·ªã l·ªói (ti·∫øn tr√¨nh < 100%)"""
        if not self.channel_videos:
            messagebox.showwarning("C·∫£nh b√°o", "Ch∆∞a c√≥ danh s√°ch video")
            return
        
        # T√¨m video c√≥ ti·∫øn tr√¨nh < 100%
        failed_indices = []
        for i, video in enumerate(self.channel_videos):
            progress = video.get('progress', 0.0)
            if progress < 100.0:
                failed_indices.append(i)
                video['selected'] = True  # T·ª± ƒë·ªông ch·ªçn video l·ªói
        
        if not failed_indices:
            messagebox.showinfo("Th√¥ng b√°o", "Kh√¥ng c√≥ video n√†o b·ªã l·ªói")
            return
        
        # C·∫≠p nh·∫≠t hi·ªÉn th·ªã
        for idx in failed_indices:
            self.update_tree_row(idx)
        
        messagebox.showinfo("Th√¥ng b√°o", f"T√¨m th·∫•y {len(failed_indices)} video l·ªói, b·∫Øt ƒë·∫ßu t·∫£i l·∫°i...")
        
        # T·∫£i l·∫°i video l·ªói
        self.download_channel_videos(selected_only=True)

    def update_channel_progress(self, percent: float):
        """C·∫≠p nh·∫≠t ti·∫øn tr√¨nh cho tab Download List Channel"""
        try:
            value = max(0, min(100, float(percent)))
        except Exception:
            value = 0.0
        self.channel_progress['value'] = value
        self.channel_progress_label.config(text=f"{value:.0f}%")
        self.root.update_idletasks()

    def on_channel_tree_click(self, event):
        """Toggle tr·∫°ng th√°i ch·ªçn ·ªü c·ªôt 'T·∫£i?' khi click"""
        try:
            region = self.channel_tree.identify('region', event.x, event.y)
            if region != 'cell':
                return
            row_id = self.channel_tree.identify_row(event.y)
            col = self.channel_tree.identify_column(event.x)
            if not row_id or col != '#4':
                return
            idx = int(self.channel_tree.index(row_id))
            if 0 <= idx < len(self.channel_videos):
                self.channel_videos[idx]['selected'] = not self.channel_videos[idx].get('selected', True)
                self.update_tree_row(idx)
        except Exception:
            pass
    
    def browse_video_file(self):
        """Ch·ªçn file video"""
        file_path = filedialog.askopenfilename(
            title="Ch·ªçn file video",
            filetypes=[("Video files", "*.mp4 *.avi *.mkv *.mov *.wmv"), ("All files", "*.*")]
        )
        if file_path:
            self.process_file_var.set(file_path)
    
    def browse_upload_file(self):
        """Ch·ªçn file upload"""
        file_path = filedialog.askopenfilename(
            title="Ch·ªçn file video",
            filetypes=[("Video files", "*.mp4 *.avi *.mkv *.mov *.wmv"), ("All files", "*.*")]
        )
        if file_path:
            self.upload_file_var.set(file_path)
    
    def process_video(self):
        """X·ª≠ l√Ω video"""
        file_path = self.process_file_var.get().strip()
        if not file_path or not os.path.exists(file_path):
            messagebox.showerror("L·ªói", "Vui l√≤ng ch·ªçn file video h·ª£p l·ªá")
            return
        
        def process_thread():
            try:
                self.update_status("ƒêang x·ª≠ l√Ω video...")
                self.process_btn.config(state="disabled")
                self.process_log.delete(1.0, tk.END)
                
                current_file = file_path
                operations = []
                
                # C·∫Øt video
                cut_option = self.cut_var.get()
                if cut_option != "none":
                    duration_map = {"1min": 60, "3min": 180, "5min": 300, "10min": 600, "30min": 1800}
                    duration = duration_map.get(cut_option, 60)
                    self.root.after(0, self.log_message, f"C·∫Øt video {cut_option}...")
                    current_file = self.processor.cut_video(current_file, duration)
                    if not current_file:
                        raise Exception("L·ªói c·∫Øt video")
                
                # Th√™m watermark
                if self.watermark_var.get():
                    self.root.after(0, self.log_message, "Th√™m watermark...")
                    current_file = self.processor.add_watermark(current_file, self.watermark_text_var.get())
                    if not current_file:
                        raise Exception("L·ªói th√™m watermark")
                
                # Thay ƒë·ªïi t·ªëc ƒë·ªô
                speed = self.speed_var.get()
                if speed != 1.0:
                    self.root.after(0, self.log_message, f"Thay ƒë·ªïi t·ªëc ƒë·ªô {speed}x...")
                    current_file = self.processor.change_speed(current_file, speed)
                    if not current_file:
                        raise Exception("L·ªói thay ƒë·ªïi t·ªëc ƒë·ªô")
                
                # L·∫≠t video
                flip_option = self.flip_var.get()
                if flip_option != "none":
                    self.root.after(0, self.log_message, f"L·∫≠t video {flip_option}...")
                    current_file = self.processor.flip_video(current_file, flip_option)
                    if not current_file:
                        raise Exception("L·ªói l·∫≠t video")
                
                # Chuy·ªÉn 9:16
                if self.convert_916_var.get():
                    self.root.after(0, self.log_message, "Chuy·ªÉn ƒë·ªïi t·ª∑ l·ªá 9:16...")
                    current_file = self.processor.convert_to_9_16(current_file)
                    if not current_file:
                        raise Exception("L·ªói chuy·ªÉn ƒë·ªïi 9:16")
                
                # Thay ƒë·ªïi MD5
                if self.change_md5_var.get():
                    self.root.after(0, self.log_message, "Thay ƒë·ªïi MD5...")
                    current_file = self.processor.change_md5(current_file)
                    if not current_file:
                        raise Exception("L·ªói thay ƒë·ªïi MD5")
                
                self.root.after(0, self.process_success, current_file)
                
            except Exception as e:
                self.root.after(0, self.process_error, str(e))
            finally:
                self.root.after(0, self.process_finish)
        
        threading.Thread(target=process_thread, daemon=True).start()
    
    def log_message(self, message):
        """Th√™m message v√†o log"""
        self.process_log.insert(tk.END, f"{message}\n")
        self.process_log.see(tk.END)
        self.root.update_idletasks()
    
    def process_success(self, file_path):
        """X·ª≠ l√Ω th√†nh c√¥ng"""
        self.processed_files.append(file_path)
        self.log_message(f"X·ª≠ l√Ω th√†nh c√¥ng: {file_path}")
        messagebox.showinfo("Th√†nh c√¥ng", f"X·ª≠ l√Ω video th√†nh c√¥ng:\n{file_path}")
    
    def process_error(self, error_msg):
        """X·ª≠ l√Ω l·ªói"""
        self.log_message(f"L·ªói: {error_msg}")
        messagebox.showerror("L·ªói", f"L·ªói x·ª≠ l√Ω video: {error_msg}")
    
    def process_finish(self):
        """K·∫øt th√∫c x·ª≠ l√Ω"""
        self.process_btn.config(state="normal")
        self.update_status("S·∫µn s√†ng")
    
    def upload_video(self):
        """Upload video"""
        file_path = self.upload_file_var.get().strip()
        if not file_path or not os.path.exists(file_path):
            messagebox.showerror("L·ªói", "Vui l√≤ng ch·ªçn file video h·ª£p l·ªá")
            return
        
        platform = self.platform_var.get()
        title = self.title_var.get().strip()
        description = self.description_var.get().strip()
        hashtags = self.hashtags_var.get().strip()
        
        def upload_thread():
            try:
                self.update_status(f"ƒêang upload l√™n {platform}...")
                self.upload_btn.config(state="disabled")
                self.upload_log.delete(1.0, tk.END)
                self.upload_log.insert(tk.END, f"B·∫Øt ƒë·∫ßu upload l√™n {platform}...\n")
                
                if platform == "tiktok":
                    success = self.uploader.upload_to_tiktok(file_path, title, hashtags)
                elif platform == "youtube":
                    success = self.uploader.upload_to_youtube(file_path, title, description)
                elif platform == "facebook":
                    success = self.uploader.upload_to_facebook(file_path, title, description)
                else:
                    raise Exception("N·ªÅn t·∫£ng kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£")
                
                if success:
                    self.root.after(0, self.upload_success)
                else:
                    self.root.after(0, self.upload_error)
                    
            except Exception as e:
                self.root.after(0, self.upload_error, str(e))
            finally:
                self.root.after(0, self.upload_finish)
        
        threading.Thread(target=upload_thread, daemon=True).start()
    
    def upload_success(self):
        """Upload th√†nh c√¥ng"""
        self.upload_log.insert(tk.END, "Upload th√†nh c√¥ng!\n")
        messagebox.showinfo("Th√†nh c√¥ng", "Upload video th√†nh c√¥ng!")
    
    def upload_error(self, error_msg=None):
        """Upload l·ªói"""
        msg = error_msg or "L·ªói upload video"
        self.upload_log.insert(tk.END, f"L·ªói: {msg}\n")
        messagebox.showerror("L·ªói", f"L·ªói upload video: {msg}")
    
    def upload_finish(self):
        """K·∫øt th√∫c upload"""
        self.upload_btn.config(state="normal")
        self.update_status("S·∫µn s√†ng")
    
    def delete_selected_file(self):
        """X√≥a file ƒë√£ ch·ªçn"""
        selection = self.files_listbox.curselection()
        if not selection:
            messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng ch·ªçn file ƒë·ªÉ x√≥a")
            return
        
        index = selection[0]
        if index < len(self.downloaded_files):
            file_path = self.downloaded_files[index]
            try:
                os.remove(file_path)
                self.downloaded_files.pop(index)
                self.files_listbox.delete(index)
                messagebox.showinfo("Th√†nh c√¥ng", "ƒê√£ x√≥a file")
            except Exception as e:
                messagebox.showerror("L·ªói", f"L·ªói x√≥a file: {e}")
    
    def open_download_folder(self):
        """M·ªü th∆∞ m·ª•c download"""
        folder_path = self.config.get('download.output_path', 'data/videos')
        if os.path.exists(folder_path):
            os.startfile(folder_path)
        else:
            messagebox.showwarning("C·∫£nh b√°o", "Th∆∞ m·ª•c kh√¥ng t·ªìn t·∫°i")
    
    def refresh_files_list(self):
        """L√†m m·ªõi danh s√°ch file"""
        self.files_listbox.delete(0, tk.END)
        self.downloaded_files.clear()
        
        folder_path = self.config.get('download.output_path', 'data/videos')
        if os.path.exists(folder_path):
            for file in os.listdir(folder_path):
                if file.lower().endswith(('.mp4', '.avi', '.mkv', '.mov', '.wmv')):
                    file_path = os.path.join(folder_path, file)
                    self.downloaded_files.append(file_path)
                    self.files_listbox.insert(tk.END, file)
    
    def browse_download_folder(self):
        """Ch·ªçn th∆∞ m·ª•c download"""
        folder = filedialog.askdirectory(title="Ch·ªçn th∆∞ m·ª•c l∆∞u video")
        if folder:
            self.download_folder_var.set(folder)
    
    def browse_process_folder(self):
        """Ch·ªçn th∆∞ m·ª•c x·ª≠ l√Ω"""
        folder = filedialog.askdirectory(title="Ch·ªçn th∆∞ m·ª•c x·ª≠ l√Ω")
        if folder:
            self.process_folder_var.set(folder)
    
    def browse_ffmpeg_path(self):
        """Ch·ªçn ƒë∆∞·ªùng d·∫´n FFmpeg"""
        file_path = filedialog.askopenfilename(
            title="Ch·ªçn file FFmpeg",
            filetypes=[("Executable files", "*.exe"), ("All files", "*.*")]
        )
        if file_path:
            self.ffmpeg_path_var.set(file_path)
    
    def save_settings(self):
        """L∆∞u c√†i ƒë·∫∑t"""
        try:
            self.config.set('download.resolution', self.resolution_var.get())
            self.config.set('download.output_path', self.download_folder_var.get())
            self.config.set('processing.output_path', self.process_folder_var.get())
            self.config.set('ffmpeg.path', self.ffmpeg_path_var.get())
            self.config.set('download.youtube_api_key', self.youtube_api_key_var.get())
            
            # C·∫≠p nh·∫≠t l·∫°i downloader v√† YouTube API theo c√†i ƒë·∫∑t m·ªõi
            self.downloader.reload_settings()
            self.youtube_api = YouTubeAPIService(self.config.get('download.youtube_api_key'))
            self.update_youtube_api_status()
            
            messagebox.showinfo("Th√†nh c√¥ng", "ƒê√£ l∆∞u c√†i ƒë·∫∑t")
        except Exception as e:
            messagebox.showerror("L·ªói", f"L·ªói l∆∞u c√†i ƒë·∫∑t: {e}")
    
    def reset_settings(self):
        """Reset c√†i ƒë·∫∑t"""
        self.resolution_var.set('1080p')
        self.download_folder_var.set('data/videos')
        self.process_folder_var.set('data/processed')
        self.ffmpeg_path_var.set('tools/ffmpeg.exe')
        self.youtube_api_key_var.set('')
        messagebox.showinfo("Th√¥ng b√°o", "ƒê√£ reset c√†i ƒë·∫∑t v·ªÅ m·∫∑c ƒë·ªãnh")
    
    def show_channel_context_menu(self, event):
        """Hi·ªÉn th·ªã menu chu·ªôt ph·∫£i cho danh s√°ch video"""
        try:
            self.channel_context_menu.tk_popup(event.x_root, event.y_root)
        except Exception as e:
            Logger.log_error(f"L·ªói hi·ªÉn th·ªã menu: {e}")
    
    def delete_selected_channel_videos(self):
        """X√≥a c√°c video ƒë√£ ch·ªçn kh·ªèi danh s√°ch"""
        # X√≥a theo c√°c d√≤ng ƒëang ƒë∆∞·ª£c ch·ªçn tr√™n Treeview
        selection = [int(self.channel_tree.index(iid)) for iid in self.channel_tree.selection()]
        if not selection:
            messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng ch·ªçn video ƒë·ªÉ x√≥a")
            return
        
        # X√°c nh·∫≠n tr∆∞·ªõc khi x√≥a
        if messagebox.askyesno("X√°c nh·∫≠n", f"B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a {len(selection)} video ƒë√£ ch·ªçn?"):
            try:
                # X√≥a theo th·ª© t·ª± ng∆∞·ª£c ƒë·ªÉ kh√¥ng ·∫£nh h∆∞·ªüng ƒë·∫øn index
                for index in reversed(selection):
                    if 0 <= index < len(self.channel_videos):
                        self.channel_videos.pop(index)
                
                # C·∫≠p nh·∫≠t l·∫°i s·ªë th·ª© t·ª±
                self.refresh_channel_list_display()
                messagebox.showinfo("Th√†nh c√¥ng", f"ƒê√£ x√≥a {len(selection)} video kh·ªèi danh s√°ch")
                
            except Exception as e:
                messagebox.showerror("L·ªói", f"L·ªói x√≥a video: {e}")
    
    def delete_all_channel_videos(self):
        """X√≥a t·∫•t c·∫£ video kh·ªèi danh s√°ch"""
        if not self.channel_videos:
            messagebox.showwarning("C·∫£nh b√°o", "Danh s√°ch video ƒë√£ tr·ªëng")
            return
        
        # X√°c nh·∫≠n tr∆∞·ªõc khi x√≥a
        if messagebox.askyesno("X√°c nh·∫≠n", f"B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a t·∫•t c·∫£ {len(self.channel_videos)} video?"):
            try:
                self.channel_videos.clear()
                self.refresh_channel_list_display()
                messagebox.showinfo("Th√†nh c√¥ng", "ƒê√£ x√≥a t·∫•t c·∫£ video kh·ªèi danh s√°ch")
                
            except Exception as e:
                messagebox.showerror("L·ªói", f"L·ªói x√≥a video: {e}")
    
    def select_all_channel_videos(self):
        """Ch·ªçn t·∫•t c·∫£ video trong danh s√°ch"""
        for i in range(len(self.channel_videos)):
            self.channel_videos[i]['selected'] = True
            self.update_tree_row(i)
    
    def deselect_all_channel_videos(self):
        """B·ªè ch·ªçn t·∫•t c·∫£ video trong danh s√°ch"""
        for i in range(len(self.channel_videos)):
            self.channel_videos[i]['selected'] = False
            self.update_tree_row(i)
    
    def refresh_channel_list_display(self):
        """L√†m m·ªõi hi·ªÉn th·ªã Treeview theo d·ªØ li·ªáu hi·ªán t·∫°i"""
        for iid in self.channel_tree.get_children():
            self.channel_tree.delete(iid)
        for i, v in enumerate(self.channel_videos, 1):
            title = v.get('title') or v.get('id') or 'Untitled'
            dur = v.get('duration') or 0
            prog = v.get('progress', 0.0)
            selected = '‚úì' if v.get('selected', True) else ''
            self.channel_tree.insert('', tk.END, values=(f"{i:02d}", f"{title} ({dur}s)", f"{prog:.0f}%", selected))

    def update_row_progress(self, index: int, percent: float):
        """C·∫≠p nh·∫≠t ph·∫ßn trƒÉm cho m·ªôt d√≤ng"""
        if 0 <= index < len(self.channel_videos):
            try:
                self.channel_videos[index]['progress'] = max(0.0, min(100.0, float(percent)))
                self.update_tree_row(index)
            except Exception:
                pass

    def update_tree_row(self, index: int):
        """C·∫≠p nh·∫≠t l·∫°i m·ªôt d√≤ng trong Treeview theo index"""
        if 0 <= index < len(self.channel_videos):
            # X√≥a d√≤ng c≈© v√† ch√®n l·∫°i t·∫°i v·ªã tr√≠ t∆∞∆°ng ·ª©ng
            children = self.channel_tree.get_children()
            if index < len(children):
                self.channel_tree.delete(children[index])
            v = self.channel_videos[index]
            title = v.get('title') or v.get('id') or 'Untitled'
            dur = v.get('duration') or 0
            prog = v.get('progress', 0.0)
            selected = '‚úì' if v.get('selected', True) else ''
            self.channel_tree.insert('', index, values=(f"{index+1:02d}", f"{title} ({dur}s)", f"{prog:.0f}%", selected))
    
    # ==================== YOUTUBE TAB METHODS ====================
    
    def update_youtube_api_status(self):
        """C·∫≠p nh·∫≠t tr·∫°ng th√°i YouTube API"""
        if self.youtube_api.is_available():
            self.api_status_var.set("‚úÖ YouTube API: S·∫µn s√†ng")
            self.api_status_label.config(foreground="green")
        else:
            self.api_status_var.set("‚ùå YouTube API: Ch∆∞a c·∫•u h√¨nh API key")
            self.api_status_label.config(foreground="red")
    
    def test_youtube_api(self):
        """Test k·∫øt n·ªëi YouTube API"""
        def test_thread():
            try:
                self.update_status("ƒêang test YouTube API...")
                success = self.youtube_api.test_api_connection()
                
                if success:
                    self.root.after(0, messagebox.showinfo, "Th√†nh c√¥ng", "YouTube API ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng!")
                    self.root.after(0, self.update_youtube_api_status)
                else:
                    self.root.after(0, messagebox.showerror, "L·ªói", "YouTube API kh√¥ng ho·∫°t ƒë·ªông. Ki·ªÉm tra API key trong Settings.")
                
            except Exception as e:
                self.root.after(0, messagebox.showerror, "L·ªói", f"L·ªói test API: {e}")
            finally:
                self.root.after(0, self.update_status, "S·∫µn s√†ng")
        
        threading.Thread(target=test_thread, daemon=True).start()
    
    def fetch_youtube_channel_list(self):
        """L·∫•y danh s√°ch video YouTube channel"""
        url = self.youtube_url_var.get().strip()
        if not url:
            messagebox.showerror("L·ªói", "Vui l√≤ng nh·∫≠p URL k√™nh YouTube")
            return
        
        if not self.youtube_api.is_available():
            messagebox.showerror("L·ªói", "YouTube API ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh. Vui l√≤ng th√™m API key trong Settings.")
            return
        
        def fetch_thread():
            try:
                self.update_status("ƒêang l·∫•y th√¥ng tin channel...")
                
                # L·∫•y th√¥ng tin channel
                channel_info = self.youtube_api.get_channel_info(url)
                if channel_info:
                    def update_channel_info():
                        self.youtube_info_text.delete(1.0, tk.END)
                        self.youtube_info_text.insert(tk.END, f"T√™n: {channel_info['title']}\n")
                        self.youtube_info_text.insert(tk.END, f"Subscribers: {channel_info['subscriber_count']:,}\n")
                        self.youtube_info_text.insert(tk.END, f"Videos: {channel_info['video_count']:,}\n")
                        self.youtube_info_text.insert(tk.END, f"Views: {channel_info['view_count']:,}\n")
                    self.root.after(0, update_channel_info)
                
                self.update_status("ƒêang l·∫•y danh s√°ch video...")
                max_videos = int(self.youtube_count_var.get())
                
                # Th·ª≠ YouTube API tr∆∞·ªõc
                videos = self.youtube_api.get_channel_videos(url, max_results=max_videos)
                
                # N·∫øu YouTube API tr·∫£ v·ªÅ √≠t video h∆°n mong mu·ªën, th·ª≠ yt-dlp
                if len(videos) < max_videos * 0.8:  # N·∫øu √≠t h∆°n 80% s·ªë video mong mu·ªën
                    Logger.log_info("YouTube API tr·∫£ v·ªÅ √≠t video, th·ª≠ yt-dlp...")
                    try:
                        yt_dlp_videos = self.downloader.list_channel_videos(url)
                        if yt_dlp_videos and len(yt_dlp_videos) > len(videos):
                            Logger.log_info(f"yt-dlp t√¨m th·∫•y {len(yt_dlp_videos)} video, s·ª≠ d·ª•ng k·∫øt qu·∫£ n√†y")
                            # Chuy·ªÉn ƒë·ªïi format t·ª´ yt-dlp sang YouTube API format
                            videos = []
                            for i, video in enumerate(yt_dlp_videos[:max_videos]):
                                videos.append({
                                    'id': video.get('id', f'video_{i}'),
                                    'title': video.get('title', 'Unknown'),
                                    'description': video.get('description', ''),
                                    'url': video.get('url', ''),
                                    'thumbnail': video.get('thumbnail', ''),
                                    'published_at': video.get('upload_date', ''),
                                    'duration': video.get('duration', 0),
                                    'view_count': video.get('view_count', 0),
                                    'like_count': 0,
                                    'comment_count': 0
                                })
                    except Exception as e:
                        Logger.log_warning(f"yt-dlp fallback th·∫•t b·∫°i: {e}")
                
                # Kh·ªüi t·∫°o th√™m thu·ªôc t√≠nh 'selected' v√† 'progress' cho m·ªói video
                self.youtube_videos = [{**v, 'selected': True, 'progress': 0.0} for v in videos]
                
                def update_ui():
                    self.refresh_youtube_list_display()
                    self.update_status(f"ƒê√£ l·∫•y {len(videos)} video")
                    self.update_youtube_progress(0)
                self.root.after(0, update_ui)
                
            except Exception as e:
                self.root.after(0, messagebox.showerror, "L·ªói", f"Kh√¥ng l·∫•y ƒë∆∞·ª£c danh s√°ch: {e}")
                self.root.after(0, self.update_status, "S·∫µn s√†ng")
        
        threading.Thread(target=fetch_thread, daemon=True).start()
    
    def download_youtube_videos(self, selected_only: bool):
        """T·∫£i c√°c video YouTube ƒë√£ ch·ªçn"""
        if not self.youtube_videos:
            messagebox.showwarning("C·∫£nh b√°o", "Ch∆∞a c√≥ danh s√°ch video ƒë·ªÉ t·∫£i")
            return
        
        if selected_only:
            indices = [i for i, v in enumerate(self.youtube_videos) if v.get('selected')]
        else:
            indices = list(range(len(self.youtube_videos)))
        
        if not indices:
            messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng ch·ªçn video ƒë·ªÉ t·∫£i")
            return
        
        def batch_thread():
            try:
                import time
                total = len(indices)
                successful_downloads = 0
                self.update_status(f"ƒêang t·∫£i danh s√°ch YouTube ({total} video)...")
                
                for idx_pos, idx in enumerate(indices, start=1):
                    video = self.youtube_videos[idx]
                    url = video.get('url')
                    title = video.get('title') or video.get('id')
                    
                    # C·∫≠p nh·∫≠t ti·∫øn tr√¨nh t·ªïng
                    self.root.after(0, self.update_youtube_progress, (idx_pos-1) * 100.0 / total)
                    self.root.after(0, self.update_youtube_row_progress, idx, 0.0)
                    
                    # Th·ª≠ t·∫£i v·ªõi retry
                    success = False
                    for retry in range(3):
                        try:
                            def hook(d):
                                try:
                                    status = d.get('status')
                                    file_percent = None
                                    if status == 'downloading':
                                        downloaded = d.get('downloaded_bytes') or 0
                                        t = d.get('total_bytes') or d.get('total_bytes_estimate') or 0
                                        if t:
                                            file_percent = downloaded * 100.0 / float(t)
                                        else:
                                            fi = d.get('fragment_index') or 0
                                            fc = d.get('fragment_count') or 0
                                            if fc:
                                                file_percent = fi * 100.0 / float(fc)
                                    elif status == 'finished':
                                        file_percent = 100.0
                                    if file_percent is not None:
                                        overall = (idx_pos-1) * 100.0 / total + (file_percent / total)
                                        self.root.after(0, self.update_youtube_progress, overall)
                                        self.root.after(0, self.update_youtube_row_progress, idx, file_percent)
                                except Exception:
                                    pass
                            
                            result = self.downloader.download_video(url, custom_filename=None, progress_hook=hook)
                            if result:
                                success = True
                                successful_downloads += 1
                                self.root.after(0, self.update_youtube_row_progress, idx, 100.0)
                                break
                            else:
                                if retry < 2:
                                    self.root.after(0, self.update_youtube_row_progress, idx, 0.0)
                                    time.sleep(2)
                                    
                        except Exception as e:
                            if retry < 2:
                                time.sleep(2)
                            else:
                                self.root.after(0, self.update_youtube_row_progress, idx, 0.0)
                    
                    if not success:
                        self.root.after(0, self.update_youtube_row_progress, idx, 0.0)
                    
                    # Delay gi·ªØa c√°c video
                    if idx_pos < total:
                        time.sleep(1)
                
                self.root.after(0, self.update_youtube_progress, 100.0)
                self.root.after(0, self.update_status, f"Ho√†n t·∫•t: {successful_downloads}/{total} video th√†nh c√¥ng")
                
            except Exception as e:
                self.root.after(0, messagebox.showerror, "L·ªói", f"L·ªói t·∫£i danh s√°ch: {e}")
                self.root.after(0, self.update_status, "S·∫µn s√†ng")
        
        threading.Thread(target=batch_thread, daemon=True).start()
    
    def retry_failed_youtube_videos(self):
        """T·∫£i l·∫°i video YouTube b·ªã l·ªói"""
        if not self.youtube_videos:
            messagebox.showwarning("C·∫£nh b√°o", "Ch∆∞a c√≥ danh s√°ch video")
            return
        
        failed_indices = []
        for i, video in enumerate(self.youtube_videos):
            progress = video.get('progress', 0.0)
            if progress < 100.0:
                failed_indices.append(i)
                video['selected'] = True
        
        if not failed_indices:
            messagebox.showinfo("Th√¥ng b√°o", "Kh√¥ng c√≥ video n√†o b·ªã l·ªói")
            return
        
        for idx in failed_indices:
            self.update_youtube_tree_row(idx)
        
        messagebox.showinfo("Th√¥ng b√°o", f"T√¨m th·∫•y {len(failed_indices)} video l·ªói, b·∫Øt ƒë·∫ßu t·∫£i l·∫°i...")
        self.download_youtube_videos(selected_only=True)
    
    def on_youtube_tree_click(self, event):
        """Toggle tr·∫°ng th√°i ch·ªçn ·ªü c·ªôt 'T·∫£i?' khi click"""
        try:
            region = self.youtube_tree.identify('region', event.x, event.y)
            if region != 'cell':
                return
            row_id = self.youtube_tree.identify_row(event.y)
            col = self.youtube_tree.identify_column(event.x)
            if not row_id or col != '#6':  # C·ªôt 'selected' l√† c·ªôt th·ª© 6
                return
            idx = int(self.youtube_tree.index(row_id))
            if 0 <= idx < len(self.youtube_videos):
                self.youtube_videos[idx]['selected'] = not self.youtube_videos[idx].get('selected', True)
                self.update_youtube_tree_row(idx)
        except Exception:
            pass
    
    def show_youtube_context_menu(self, event):
        """Hi·ªÉn th·ªã menu chu·ªôt ph·∫£i cho danh s√°ch video YouTube"""
        try:
            self.youtube_context_menu.tk_popup(event.x_root, event.y_root)
        except Exception as e:
            Logger.log_error(f"L·ªói hi·ªÉn th·ªã menu: {e}")
    
    def delete_selected_youtube_videos(self):
        """X√≥a c√°c video YouTube ƒë√£ ch·ªçn kh·ªèi danh s√°ch"""
        selection = [int(self.youtube_tree.index(iid)) for iid in self.youtube_tree.selection()]
        if not selection:
            messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng ch·ªçn video ƒë·ªÉ x√≥a")
            return
        
        if messagebox.askyesno("X√°c nh·∫≠n", f"B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a {len(selection)} video ƒë√£ ch·ªçn?"):
            try:
                for index in reversed(selection):
                    if 0 <= index < len(self.youtube_videos):
                        self.youtube_videos.pop(index)
                
                self.refresh_youtube_list_display()
                messagebox.showinfo("Th√†nh c√¥ng", f"ƒê√£ x√≥a {len(selection)} video kh·ªèi danh s√°ch")
                
            except Exception as e:
                messagebox.showerror("L·ªói", f"L·ªói x√≥a video: {e}")
    
    def delete_all_youtube_videos(self):
        """X√≥a t·∫•t c·∫£ video YouTube kh·ªèi danh s√°ch"""
        if not self.youtube_videos:
            messagebox.showwarning("C·∫£nh b√°o", "Danh s√°ch video ƒë√£ tr·ªëng")
            return
        
        if messagebox.askyesno("X√°c nh·∫≠n", f"B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a t·∫•t c·∫£ {len(self.youtube_videos)} video?"):
            try:
                self.youtube_videos.clear()
                self.refresh_youtube_list_display()
                messagebox.showinfo("Th√†nh c√¥ng", "ƒê√£ x√≥a t·∫•t c·∫£ video kh·ªèi danh s√°ch")
                
            except Exception as e:
                messagebox.showerror("L·ªói", f"L·ªói x√≥a video: {e}")
    
    def select_all_youtube_videos(self):
        """Ch·ªçn t·∫•t c·∫£ video YouTube trong danh s√°ch"""
        for i in range(len(self.youtube_videos)):
            self.youtube_videos[i]['selected'] = True
            self.update_youtube_tree_row(i)
    
    def deselect_all_youtube_videos(self):
        """B·ªè ch·ªçn t·∫•t c·∫£ video YouTube trong danh s√°ch"""
        for i in range(len(self.youtube_videos)):
            self.youtube_videos[i]['selected'] = False
            self.update_youtube_tree_row(i)
    
    def refresh_youtube_list_display(self):
        """L√†m m·ªõi hi·ªÉn th·ªã Treeview YouTube theo d·ªØ li·ªáu hi·ªán t·∫°i"""
        for iid in self.youtube_tree.get_children():
            self.youtube_tree.delete(iid)
        for i, v in enumerate(self.youtube_videos, 1):
            title = v.get('title') or v.get('id') or 'Untitled'
            duration = v.get('duration') or 0
            views = v.get('view_count') or 0
            prog = v.get('progress', 0.0)
            selected = '‚úì' if v.get('selected', True) else ''
            
            # Format duration
            dur_str = f"{duration//60}:{duration%60:02d}" if duration > 0 else "0:00"
            # Format views
            views_str = f"{views:,}" if views > 0 else "0"
            
            self.youtube_tree.insert('', tk.END, values=(
                f"{i:02d}", 
                title[:60] + "..." if len(title) > 60 else title,
                dur_str,
                views_str,
                f"{prog:.0f}%", 
                selected
            ))
    
    def update_youtube_row_progress(self, index: int, percent: float):
        """C·∫≠p nh·∫≠t ph·∫ßn trƒÉm cho m·ªôt d√≤ng YouTube"""
        if 0 <= index < len(self.youtube_videos):
            try:
                self.youtube_videos[index]['progress'] = max(0.0, min(100.0, float(percent)))
                self.update_youtube_tree_row(index)
            except Exception:
                pass
    
    def update_youtube_tree_row(self, index: int):
        """C·∫≠p nh·∫≠t l·∫°i m·ªôt d√≤ng trong Treeview YouTube theo index"""
        if 0 <= index < len(self.youtube_videos):
            children = self.youtube_tree.get_children()
            if index < len(children):
                self.youtube_tree.delete(children[index])
            v = self.youtube_videos[index]
            title = v.get('title') or v.get('id') or 'Untitled'
            duration = v.get('duration') or 0
            views = v.get('view_count') or 0
            prog = v.get('progress', 0.0)
            selected = '‚úì' if v.get('selected', True) else ''
            
            dur_str = f"{duration//60}:{duration%60:02d}" if duration > 0 else "0:00"
            views_str = f"{views:,}" if views > 0 else "0"
            
            self.youtube_tree.insert('', index, values=(
                f"{index+1:02d}", 
                title[:60] + "..." if len(title) > 60 else title,
                dur_str,
                views_str,
                f"{prog:.0f}%", 
                selected
            ))
    
    def update_youtube_progress(self, percent: float):
        """C·∫≠p nh·∫≠t ti·∫øn tr√¨nh cho tab YouTube"""
        try:
            value = max(0, min(100, float(percent)))
        except Exception:
            value = 0.0
        self.youtube_progress['value'] = value
        self.youtube_progress_label.config(text=f"{value:.0f}%")
        self.root.update_idletasks()
    
    def run(self):
        """Ch·∫°y ·ª©ng d·ª•ng"""
        # T·∫°o th∆∞ m·ª•c c·∫ßn thi·∫øt
        FileManager.ensure_dir('data/videos')
        FileManager.ensure_dir('data/processed')
        FileManager.ensure_dir('data/music')
        FileManager.ensure_dir('data/fonts')
        FileManager.ensure_dir('logs')
        
        # L√†m m·ªõi danh s√°ch file
        self.refresh_files_list()
        
        # Ch·∫°y ·ª©ng d·ª•ng
        self.root.mainloop()

if __name__ == "__main__":
    app = TikTokReupApp()
    app.run()
